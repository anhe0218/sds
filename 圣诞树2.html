<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic Tree - The Star is Back!</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; z-index: 1; }
        #video-input {
            position: fixed; right: 20px; bottom: 20px; width: 160px; height: 120px;
            opacity: 0.6; z-index: 20; border: 1px solid #FFD700; border-radius: 8px;
            background: #000; pointer-events: none; transform: scaleX(-1);
        }
        #status-pill {
            position: absolute; top: 20px; left: 20px; padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7); border: 1px solid #FFD700;
            border-radius: 20px; color: #FFD700; font-size: 13px; z-index: 10;
        }
        #christmas-text {
            position: absolute; top: 15%; left: 50%; transform: translate(-50%, -50%);
            font-size: 3.5rem; color: #FFD700; text-shadow: 0 0 15px #FFD700;
            z-index: 5; opacity: 0; font-family: serif; pointer-events: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="status-pill">正在召唤星星...</div>
    <h1 id="christmas-text">MERRY CHRISTMAS</h1>
    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>

<script>
    const CONFIG = {
        treeLevels: 10,
        boxSize: 0.8,
        scatterRange: 8, 
        cameraDistance: 30
    };

    let scene, camera, renderer, giftTreeGroup, starGlow;
    let items = []; // 存储所有盒子和星星
    let openness = 0, currentOpenness = 0;

    window.onload = () => {
        initThreeJS();
        initMediaPipe();
        animate();
    };

    function initThreeJS() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, CONFIG.cameraDistance);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.9));
        const pLight = new THREE.PointLight(0xffd700, 2, 100);
        pLight.position.set(0, 15, 10);
        scene.add(pLight);

        createTreeWithStar();
        window.addEventListener('resize', onWindowResize);
    }

    // 创建树和星星
    function createTreeWithStar() {
        giftTreeGroup = new THREE.Group();
        const colors = [0xC41E3A, 0x228B22, 0xFFFFFF]; // 红、绿、白
        const boxGeom = new THREE.BoxGeometry(1, 1, 1);
        
        const getBoxMat = (col) => {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#' + new THREE.Color(col).getHexString();
            ctx.fillRect(0,0,64,64);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(28,0,8,64); ctx.fillRect(0,28,64,8);
            return new THREE.MeshStandardMaterial({ 
                map: new THREE.CanvasTexture(canvas), 
                emissive: col, emissiveIntensity: 0.2 
            });
        };

        // 1. 生成礼盒
        let yOffset = 0;
        for (let i = 0; i < CONFIG.treeLevels; i++) {
            const ratio = i / CONFIG.treeLevels;
            const radius = 5 * (1 - ratio) + 0.3;
            const size = CONFIG.boxSize * (1 - ratio * 0.3);
            const count = Math.max(1, Math.floor((Math.PI * 2 * radius) / (size * 1.3)));

            for (let j = 0; j < count; j++) {
                const angle = (j / count) * Math.PI * 2 + i * 0.4;
                const box = new THREE.Mesh(boxGeom, getBoxMat(colors[Math.floor(Math.random() * colors.length)]));
                const px = Math.cos(angle) * radius;
                const pz = Math.sin(angle) * radius;
                
                box.position.set(px, yOffset, pz);
                box.scale.setScalar(size);
                box.userData = {
                    originPos: box.position.clone(),
                    originRot: box.rotation.clone(),
                    dir: new THREE.Vector3(px, yOffset * 0.2 + 0.5, pz).normalize(),
                    spin: new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5)
                };
                items.push(box);
                giftTreeGroup.add(box);
            }
            yOffset += size * 0.9;
        }

        // 2. 生成最顶端的黄金星
        const starGeo = new THREE.OctahedronGeometry(1.2, 0);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.y = yOffset + 0.5;
        
        // 星星的散开数据：垂直向上飞
        star.userData = {
            originPos: star.position.clone(),
            originRot: star.rotation.clone(),
            dir: new THREE.Vector3(0, 1.5, 0), // 垂直向上散射
            spin: new THREE.Vector3(0, 1, 0),
            isStar: true
        };

        // 3. 星星光晕效果
        const glowCanvas = document.createElement('canvas');
        glowCanvas.width = 64; glowCanvas.height = 64;
        const gCtx = glowCanvas.getContext('2d');
        const grad = gCtx.createRadialGradient(32,32,0,32,32,32);
        grad.addColorStop(0, 'rgba(255, 255, 0, 1)');
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        gCtx.fillStyle = grad; gCtx.fillRect(0,0,64,64);

        starGlow = new THREE.Sprite(new THREE.SpriteMaterial({
            map: new THREE.CanvasTexture(glowCanvas),
            blending: THREE.AdditiveBlending,
            transparent: true
        }));
        starGlow.scale.set(6, 6, 1);
        star.add(starGlow); // 光晕跟随星星

        items.push(star);
        giftTreeGroup.add(star);

        giftTreeGroup.position.y = -yOffset / 2;
        scene.add(giftTreeGroup);
    }

    function initMediaPipe() {
        const videoElement = document.getElementById('video-input');
        const statusPill = document.getElementById('status-pill');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });
        hands.onResults(results => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                statusPill.innerText = "魔法开启：尝试快速张开手";
                const lm = results.multiHandLandmarks[0];
                const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                openness = Math.min(1, Math.max(0, (dist - 0.05) * 4.5)); 
            } else {
                statusPill.innerText = "手势连接中...";
                openness = 0;
            }
        });

        const cam = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cam.start();
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001;
        currentOpenness += (openness - currentOpenness) * 0.12;

        items.forEach((item) => {
            const dist = currentOpenness * CONFIG.scatterRange;
            // 更新位置：基础位置 + 散射方向 * 距离
            item.position.x = item.userData.originPos.x + item.userData.dir.x * dist;
            item.position.y = item.userData.originPos.y + item.userData.dir.y * dist;
            item.position.z = item.userData.originPos.z + item.userData.dir.z * dist;

            // 更新旋转
            if (item.userData.isStar) {
                item.rotation.y += 0.05; // 星星一直自转
                starGlow.scale.setScalar(5 + Math.sin(time*10) + currentOpenness * 5);
            } else {
                item.rotation.x += item.userData.spin.x * currentOpenness * 0.1;
                item.rotation.y += item.userData.spin.y * currentOpenness * 0.1;
            }
        });

        giftTreeGroup.rotation.y += 0.005 + currentOpenness * 0.02;

        const text = document.getElementById('christmas-text');
        text.style.opacity = currentOpenness > 0.6 ? 1 : 0;
        text.style.transform = `translate(-50%, -50%) scale(${0.8 + currentOpenness * 0.4})`;

        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
</script>
</body>
</html>